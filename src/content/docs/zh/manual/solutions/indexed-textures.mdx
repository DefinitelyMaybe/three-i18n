---
title: ä½¿ç”¨çº¹ç†ç´¢å¼•æ¥æ‹¾å–å’Œç€è‰²
sidebar:
  order: 9
---

è¿™ç¯‡æ–‡ç« æ˜¯ [å¯¹é½HTMLå…ƒç´ åˆ°3Då¯¹è±¡](align-html-elements-to-3d.html) çš„å»¶ç»­ã€‚
å¦‚æœä½ è¿˜æ²¡æœ‰è¯»è¿‡ä¸Šç¯‡æ–‡ç« ï¼Œä½ åº”è¯¥å…ˆä»é‚£é‡Œå¼€å§‹ï¼Œç„¶åå†å›æ¥ç»§ç»­é˜…è¯»ã€‚

æœ‰æ—¶å€™ä½¿ç”¨Three.jséœ€è¦æå‡ºä¸€äº›åˆ›é€ æ€§çš„è§£å†³æ€è·¯ã€‚æˆ‘ä¸ç¡®å®šè¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„è§£å†³æ–¹æ¡ˆï¼Œä½†æˆ‘æƒ³æˆ‘ä¼šåˆ†äº«å®ƒï¼Œä½ å¯ä»¥çœ‹çœ‹æ˜¯å¦å¯ä»¥ä¸ºä½ çš„éœ€æ±‚æä¾›äº†ä¸€äº›è§£å†³æ€è·¯æˆ–æ–¹æ¡ˆã€‚

åœ¨ [ä¸Šä¸€ç¯‡æ–‡ç« ä¸­](align-html-elements-to-3d.html)ï¼Œæˆ‘ä»¬åœ¨3Dåœ°çƒå‘¨å›´æ˜¾ç¤ºäº†å›½å®¶åç§°ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¦‚ä½•åšåˆ°ï¼Œè®©ç”¨æˆ·é€‰ä¸­ä¸€ä¸ªå›½å®¶å¹¶é«˜äº®ä»–çš„é€‰æ‹©ï¼Ÿ

ç¬¬ä¸€ä¸ªæƒ³æ³•æ˜¯ä¸ºæ¯ä¸ªå›½å®¶ç”Ÿæˆå‡ ä½•å›¾å½¢ï¼Œæˆ‘ä»¬å¯ä»¥ [ä½¿ç”¨å°„çº¿æ‹¾å–](picking.html) ï¼Œå°±åƒä¹‹å‰ä»‹ç»çš„é‚£æ ·ã€‚
æˆ‘ä»¬å°†ä¸ºæ¯ä¸ªå›½å®¶æ„å»º3Då‡ ä½•å¯¹è±¡ã€‚å¦‚æœç”¨æˆ·ç‚¹å‡»ä»£è¡¨é‚£ä¸ªå›½å®¶çš„ç½‘æ ¼å¯¹è±¡ï¼Œæˆ‘ä»¬å°±ä¼šçŸ¥é“å¯¹åº”çš„å›½å®¶è¢«ç‚¹å‡»äº†ã€‚

æ‰€ä»¥ï¼Œä¸ºäº†éªŒè¯è¿™ä¸ªè§£å†³æ–¹æ¡ˆï¼Œæˆ‘å°è¯•ç”Ÿæˆæ‰€æœ‰å›½å®¶çš„3Dç½‘æ ¼å¯¹è±¡ï¼Œä½¿ç”¨äº†[åœ¨ä¸Šä¸€ç¯‡æ–‡ç« ä¸­](align-html-elements-to-3d.html)å’Œæˆ‘ç”Ÿæˆè½®å»“ä¸€æ ·çš„æ•°æ®ã€‚
ç»“æœç”Ÿæˆäº†15.5mçš„äºŒè¿›åˆ¶GLTF(.glb)æ–‡ä»¶ï¼Œè®©ç”¨æˆ·ä¸‹è½½15.5mçš„æ•°æ®å¯¹äºæˆ‘æ¥è¯´å®åœ¨å¤ªå¤šäº†ã€‚

æœ‰å¾ˆå¤šæ–¹æ³•å¯ä»¥å‹ç¼©æ•°æ®ã€‚ç¬¬ä¸€ç§å¯èƒ½æ˜¯åº”ç”¨ä¸€äº›ç®—æ³•æ¥é™ä½è½®å»“çš„åˆ†è¾¨ç‡ï¼Œä½†æ˜¯æˆ‘æ²¡æœ‰èŠ±æ—¶é—´æ¥ç ”ç©¶å®ƒã€‚å¯èƒ½å‡ºç°ç¾å›½è¾¹ç•Œå˜å¤§è€ŒåŠ æ‹¿å¤§è¾¹ç•Œå˜å°çš„æƒ…å†µã€‚

å¦ä¸€ç§è§£å†³æ–¹æ¡ˆæ˜¯ä»…ä½¿ç”¨æ•°æ®å‹ç¼©ï¼Œæ¯”å¦‚gzipå°†å…¶é™è‡³11mï¼Œè¿™å‡å°‘äº†30%ï¼Œä½†æ˜¯è¿˜ä¸å¤Ÿã€‚

æˆ‘ä»¬å¯ä»¥å°†æ‰€æœ‰æ•°æ®å­˜å‚¨ä¸º16ä½è€Œä¸æ˜¯32ä½æµ®ç‚¹å€¼ã€‚æˆ–è€…æˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨åƒ[draco å‹ç¼©](https://google.github.io/draco/)
è¿™ç§ä¸œè¥¿ä¹Ÿè®¸å°±å¤Ÿäº†ã€‚ä¸è¿‡æˆ‘æ²¡æœ‰å»è¯•ï¼Œæˆ‘æ¨èä½ å»è¯•ä¸‹å›æ¥å‘Šè¯‰æˆ‘æ˜¯æ€ä¹ˆå›äº‹ï¼Œå› ä¸ºæˆ‘å¾ˆæƒ³çŸ¥é“ğŸ˜…

å°±æˆ‘è€Œè¨€ï¼Œæˆ‘è€ƒè™‘ä½¿ç”¨ [GPUæ‹¾å–æ–¹æ¡ˆ](picking.html)ï¼Œ
è¿™åœ¨ä¸Šä¸€ç¯‡ [å…³äºæ‹¾å–çš„æ–‡ç« ](picking.html) çš„æœ€åæœ‰æåˆ°ã€‚è¿™ç§æ–¹æ¡ˆä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ç§ç‹¬ç‰¹çš„é¢œè‰²ä»£è¡¨ä¸åŒç½‘æ ¼å¯¹è±¡çš„IDï¼Œç„¶åæˆ‘ä»¬ç»˜åˆ¶äº†æ‰€æœ‰ç½‘æ ¼ï¼Œçœ‹çœ‹å“ªä¸ªé¢œè‰²è¢«ç‚¹å‡»äº†ã€‚

åŸºäºè¿™ç§çµæ„Ÿï¼Œæˆ‘ä»¬å¯ä»¥é¢„å…ˆç”Ÿæˆä¸€å¼ å›½å®¶çš„åœ°å›¾ï¼Œæ¯ä¸ªå›½å®¶çš„é¢œè‰²æ˜¯å®ƒåœ¨å›½å®¶æ•°ç»„ä¸­çš„ç´¢å¼•å·ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç±»ä¼¼GPUæ‹¾å–æŠ€æœ¯ï¼Œæˆ‘ä»¬ä½¿ç”¨ç´¢å¼•çº¹ç†ç»˜åˆ¶ä¸€ä¸ªç¦»å±å…¨å±€ç”»å¸ƒï¼ŒæŸ¥çœ‹é¢œè‰²ä¼šå‘Šè¯‰æˆ‘ä»¬ç”¨æˆ·ç‚¹å‡»äº†é‚£ä¸ªå›½å®¶IDã€‚

å› æ­¤ï¼Œæˆ‘ [å†™äº†ä¸€äº›ä»£ç ](https://github.com/mrdoob/three.js/blob/master/manual/resources/tools/geo-picking/)
ç”Ÿæˆè¿™æ ·çš„ä¸€ä¸ªçº¹ç†ï¼Œåœ¨è¿™é‡Œï¼š

<div class="threejs_center">
  ![image](/resources/data/world/country-index-texture.png)
</div>

æ³¨æ„ï¼šç”Ÿæˆè¿™ä»½çº¹ç†çš„æ•°æ®æ¥æºäº [è¿™ä¸ªç½‘ç«™](http://thematicmapping.org/downloads/world_borders.php)
ï¼Œä½¿ç”¨çš„åè®®æ˜¯ [CC-BY-SA](http://creativecommons.org/licenses/by-sa/3.0/)ã€‚

å®ƒåªæœ‰217kï¼Œæ¯”å›½å®¶ç½‘æ ¼å¯¹è±¡çš„15mè¦å¥½å¾—å¤šï¼Œäº‹å®ä¸Šæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ›´ä½çš„åˆ†è¾¨ç‡ï¼Œä½†ç°åœ¨217kä¼¼ä¹å·²ç»è¶³å¤Ÿäº†ã€‚

æ‰€ä»¥è®©æˆ‘ä»¬è¯•ç€ç”¨å®ƒæ¥é€‰æ‹©å›½å®¶ã€‚

ä» [GPUæ‹¾å–æ¡ˆä¾‹ä¸­](picking.html) è·å–ä»£ç ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªåœºæ™¯æ¥åšæ‹¾å–ã€‚

```js
const pickingScene = new THREE.Scene();
pickingScene.background = new THREE.Color(0);
```

æˆ‘ä»¬éœ€è¦å°†å¸¦æœ‰ç´¢å¼•çº¹ç†çš„åœ°çƒæ·»åŠ åˆ°æ‹¾å–åœºæ™¯ä¸­ã€‚

```js
{
const loader = new THREE.TextureLoader();
const geometry = new THREE.SphereGeometry(1, 64, 32);

+  const indexTexture = loader.load('resources/data/world/country-index-texture.png', render);
+  indexTexture.minFilter = THREE.NearestFilter;
+  indexTexture.magFilter = THREE.NearestFilter;
+
+  const pickingMaterial = new THREE.MeshBasicMaterial({map: indexTexture});
+  pickingScene.add(new THREE.Mesh(geometry, pickingMaterial));

const texture = loader.load('resources/data/world/country-outlines-4k.png', render);
const material = new THREE.MeshBasicMaterial({map: texture});
scene.add(new THREE.Mesh(geometry, material));
}
```

ç„¶åæˆ‘ä»¬æŠŠ `GPUPickingHelper`è¿™ä¸ªç±»æ‹·è´ä¸‹ï¼Œåœ¨ä½¿ç”¨å‰æˆ‘ä»¬éœ€è¦åšä¸€äº›å°æ”¹åŠ¨

```js
class GPUPickHelper {
constructor() {
// åˆ›é€ ä¸€ä¸ª 1x1 çš„æ¸²æŸ“å¯¹è±¡
this.pickingTexture = new THREE.WebGLRenderTarget(1, 1);
this.pixelBuffer = new Uint8Array(4);
-    this.pickedObject = null;
-    this.pickedObjectSavedColor = 0;
}
pick(cssPosition, scene, camera) {
const {pickingTexture, pixelBuffer} = this;

// å°†è§†å›¾åç§»è®¾ç½®ä¸ºä»…è¡¨ç¤ºé¼ æ ‡ä¸‹å•ä¸ªå…ƒç´ 
const pixelRatio = renderer.getPixelRatio();
camera.setViewOffset(
renderer.getContext().drawingBufferWidth,   // full width
renderer.getContext().drawingBufferHeight,  // full top
cssPosition.x * pixelRatio | 0,             // rect x
cssPosition.y * pixelRatio | 0,             // rect y
1,                                          // rect width
1,                                          // rect height
);
// æ¸²æŸ“åœºæ™¯
renderer.setRenderTarget(pickingTexture);
renderer.render(scene, camera);
renderer.setRenderTarget(null);
// æ¸…é™¤è§†å›¾åç§»ï¼Œä½¿æ¸²æŸ“æ¢å¤æ­£å¸¸
camera.clearViewOffset();
// è¯»å–åƒç´ 
renderer.readRenderTargetPixels(
pickingTexture,
0,   // x
0,   // y
1,   // width
1,   // height
pixelBuffer);

+    const id =
+        (pixelBuffer[0] << 16) |
+        (pixelBuffer[1] <<  8) |
+        (pixelBuffer[2] <<  0);
+
+    return id;
-    const id =
-        (pixelBuffer[0] << 16) |
-        (pixelBuffer[1] <<  8) |
-        (pixelBuffer[2]      );
-    const intersectedObject = idToObject[id];
-    if (intersectedObject) {
-      // è·å–ç¬¬ä¸€ä¸ªå¯¹è±¡ï¼Œå®ƒæ˜¯ç¦»æˆ‘ä»¬æœ€è¿‘çš„
-      this.pickedObject = intersectedObject;
-      // ä¿å­˜å®ƒçš„é¢œè‰²
-      this.pickedObjectSavedColor = this.pickedObject.material.emissive.getHex();
-      // å°†å…¶è‡ªå‘å…‰é¢œè‰²è®¾ç½®ä¸ºé—ªçƒçš„çº¢è‰²/é»„è‰²
-      this.pickedObject.material.emissive.setHex((time * 8) % 2 > 1 ? 0xFFFF00 : 0xFF0000);
-    }
}
}
```

ç°åœ¨æˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥é€‰æ‹©å›½å®¶äº†ã€‚

```js
const pickHelper = new GPUPickHelper();

function getCanvasRelativePosition(event) {
const rect = canvas.getBoundingClientRect();
return {
x: (event.clientX - rect.left) * canvas.width  / rect.width,
y: (event.clientY - rect.top ) * canvas.height / rect.height,
};
}

function pickCountry(event) {
// å¦‚æœæˆ‘ä»¬è¿˜æ²¡æœ‰åŠ è½½å¥½æ•°æ®ï¼Œé€€å‡º
if (!countryInfos) {
return;
}

const position = getCanvasRelativePosition(event);
const id = pickHelper.pick(position, pickingScene, camera);
if (id > 0) {
// æˆ‘ä»¬ç‚¹å‡»äº†ä¸€ä¸ªå›½å®¶ï¼Œä¿®æ”¹å®ƒçš„selectedå±æ€§
const countryInfo = countryInfos[id - 1];
const selected = !countryInfo.selected;
// å¦‚æœæˆ‘ä»¬é€‰ä¸­è¿™ä¸ªå›½å®¶ï¼Œå¹¶ä¸”æ²¡æœ‰æŒ‰ä½æ§åˆ¶é”®ï¼Œå–æ¶ˆæ‰€æœ‰é€‰ä¸­çš„å›½å®¶
if (selected &amp;&amp; !event.shiftKey &amp;&amp; !event.ctrlKey &amp;&amp; !event.metaKey) {
unselectAllCountries();
}
numCountriesSelected += selected ? 1 : -1;
countryInfo.selected = selected;
} else if (numCountriesSelected) {
// æµ·æ´‹æˆ–è€…å¤©ç©ºè¢«é€‰ä¸­äº†
unselectAllCountries();
}
requestRenderIfNotRequested();
}

function unselectAllCountries() {
numCountriesSelected = 0;
countryInfos.forEach((countryInfo) => {
countryInfo.selected = false;
});
}

canvas.addEventListener('pointerup', pickCountry);
```

ä¸Šé¢çš„ä»£ç ï¼Œè®¾ç½®/é‡ç½®äº†å›½å®¶æ•°ç»„å…ƒç´ çš„ `selected` å±æ€§ã€‚å¦‚æœ `shift` æˆ– `ctrl` æˆ– `cmd`
è¢«æŒ‰ä¸‹äº†ï¼Œä½ å°±å¯ä»¥é€‰æ‹©å¤šä¸ªå›½å®¶ã€‚

å‰©ä¸‹çš„å°±æ˜¯æ˜¾ç¤ºé€‰æ‹©çš„å›½å®¶ï¼Œç°åœ¨è®©æˆ‘ä»¬æ›´æ–°æ ‡ç­¾

```js
function updateLabels() {
// å¦‚æœæˆ‘ä»¬è¿˜æ²¡æœ‰åŠ è½½å¥½æ•°æ®ï¼Œé€€å‡º
if (!countryInfos) {
return;
}

const large = settings.minArea * settings.minArea;
// è·å–è¡¨ç¤ºç›¸æœºæ­£å¯¹æ–¹å‘çš„çŸ©é˜µ
normalMatrix.getNormalMatrix(camera.matrixWorldInverse);
// è·å–ç›¸æœºä½ç½®
camera.getWorldPosition(cameraPosition);
for (const countryInfo of countryInfos) {
-    const {position, elem, area} = countryInfo;
-    // è¶³å¤Ÿå¤§äº†ï¼Ÿ
-    if (area < large) {
+    const {position, elem, area, selected} = countryInfo;
+    const largeEnough = area >= large;
+    const show = selected || (numCountriesSelected === 0 &amp;&amp; largeEnough);
+    if (!show) {
elem.style.display = 'none';
continue;
}

...
```

é€šè¿‡ä¸Šé¢çš„ä»£ç ï¼Œæˆ‘ä»¬å°±æœ‰èƒ½åŠ›æ‹¾å–å¯¹åº”çš„å›½å®¶äº†ã€‚

<iframe src="/editor?url=/manual/examples/indexed-textures-picking.html"></iframe>

ä»£ç ä»ç„¶ä¼šæ ¹æ®åœ°åŒºæ˜¾ç¤ºå¯¹åº”çš„å›½å®¶ã€‚ä¸è¿‡å¦‚æœä½ ç‚¹å‡»ä¸€ä¸ªï¼Œåªä¼šæ˜¾ç¤ºå¯¹åº”çš„æ ‡ç­¾ã€‚

æ‰€ä»¥è¿™ä¼¼ä¹æ˜¯é€‰æ‹©å›½å®¶çš„æœ‰æ•ˆè§£å†³æ–¹æ¡ˆï¼Œä½†æ˜¯å¦‚ä½•çªå‡ºæ˜¾ç¤ºé€‰å®šçš„å›½å®¶ï¼Ÿ

æˆ‘ä»¬å¯ä»¥ä» _è°ƒè‰²æ¿å›¾å½¢ç®—æ³•_ ä¸­è·å–çµæ„Ÿã€‚

[è°ƒè‰²æ¿ç®—æ³•](https://en.wikipedia.org/wiki/Palette_%28computing%29)
æˆ–è€… [ç´¢å¼•é¢œè‰²](https://en.wikipedia.org/wiki/Indexed_color)
æ˜¯è¢«æ—§çš„ç³»ç»Ÿï¼Œæ¯”å¦‚Atari 800ã€Amigaã€NESã€Super NintendolderåŠIBM
PCsæ‰€ä½¿ç”¨çš„ã€‚å¹¶éä»¥RGBAçš„å½¢å¼ç»™æ¯ä¸ªé¢œè‰²å­˜å‚¨8ä½ã€æ¯ä¸ªåƒç´ è‡³å°‘32å­—èŠ‚çš„ä½å›¾ï¼Œä»–ä»¬å­˜å‚¨ä½å›¾æ˜¯8ä½æˆ–è€…æ›´å°‘ã€‚æ¯ä¸ªåƒç´ éƒ½æ˜¯ä¸€ä¸ªè°ƒè‰²æ¿çš„ç´¢å¼•å€¼ï¼Œ
æ‰€ä»¥ä¸¾ä¾‹ä¸€ä¸ªåƒç´ å€¼ä¸º3ï¼Œè¡¨ç¤ºâ€œæ˜¾ç¤º3å·é¢œè‰²å€¼â€ï¼Œè€Œå®šä¹‰3å·é¢œè‰²å€¼çš„åœ°æ–¹å°±å«â€œè°ƒè‰²æ¿â€ã€‚

åœ¨JavaScriptä¸­å°±åƒè¿™æ ·ï¼š

```js
const face7x7PixelImageData = [
  0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 2, 0, 2, 0, 1, 1, 0, 0, 0, 0,
  0, 1, 1, 0, 3, 3, 3, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1,
];

const palette = [
  [255, 255, 255], // ç™½
  [0, 0, 0], // é»‘
  [0, 255, 255], // é’
  [255, 0, 0], // çº¢
];
```

å›¾åƒæ•°æ®ä¸­æ¯ä¸ªåƒç´ éƒ½æ˜¯è°ƒè‰²æ¿çš„ç´¢å¼•ï¼Œå¦‚æœä½ åˆ†æä¸Šé¢è°ƒè‰²æ¿çš„æ•°æ®ä½ ä¼šå¾—åˆ°è¿™ä¸ªå›¾åƒï¼š

<div class="threejs_center">
  ![image](/resources/images/7x7-indexed-face.png)
</div>

åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œä¸Šé¢å·²ç»æœ‰ä¸€ä¸ªç”¨ä¸åŒidä»£è¡¨ä¸åŒå›½å®¶çš„çº¹ç†äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡è°ƒè‰²æ¿ä½¿ç”¨ç›¸åŒçš„çº¹ç†èµ‹äºˆæ¯ä¸ªå›½å®¶å„è‡ªçš„é¢œè‰²ã€‚é€šè¿‡æ›´æ”¹è°ƒè‰²æ¿é¢œè‰²æˆ‘ä»¬å¯ä»¥ä¸ºå•ç‹¬çš„å›½å®¶ç€è‰²ã€‚æ¯”å¦‚é€šè¿‡è®¾ç½®æ•´ä¸ªè°ƒè‰²æ¿çº¹ç†ä¸ºé»‘è‰²ï¼Œç»™æŸä¸ªå›½å®¶ä½¿ç”¨ä¸åŒçš„é¢œè‰²ï¼Œå°±å¯ä»¥å‡¸æ˜¾é‚£ä¸ªå›½å®¶äº†ã€‚

è¦åšè°ƒè‰²æ¿ç´¢å¼•çš„è¯ï¼Œéœ€è¦ä¸€äº›è‡ªå®šä¹‰ç€è‰²å™¨ä»£ç ï¼Œè®©æˆ‘ä»¬ä¿®æ”¹Three.jsä¸­é»˜è®¤çš„ç€è‰²å™¨ï¼Œè¿™æ ·æˆ‘ä»¬ä¹Ÿå¯ä»¥æ ¹æ®éœ€è¦ä½¿ç”¨ç…§æ˜æˆ–å…¶ä»–ç‰¹æ€§ã€‚

å°±åƒæˆ‘ä»¬åœ¨ [å¤§é‡ç§»åŠ¨ç‰©ä½“çš„ä¼˜åŒ–](optimize-lots-of-objects-animated.html) è¿™ç¯‡æ–‡ç« ä¸­æåˆ°çš„ï¼Œé€šè¿‡
`onBeforeCompile` å±æ€§ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å‘æè´¨æ·»åŠ å‡½æ•°æ¥ä¿®æ”¹é»˜è®¤çš„ç€è‰²å™¨ã€‚

é»˜è®¤çš„ç‰‡å…ƒç€è‰²å™¨åœ¨ç¼–è¯‘ä¹‹å‰çœ‹èµ·æ¥å°±åƒè¿™æ ·ï¼š

```glsl
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
#include <clipping_planes_fragment>
vec4 diffuseColor = vec4( diffuse, opacity );
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <specularmap_fragment>
ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
#ifdef USE_LIGHTMAP
reflectedLight.indirectDiffuse += texture2D( lightMap, vLightMapUv ).xyz * lightMapIntensity;
#else
reflectedLight.indirectDiffuse += vec3( 1.0 );
#endif
#include <aomap_fragment>
reflectedLight.indirectDiffuse *= diffuseColor.rgb;
vec3 outgoingLight = reflectedLight.indirectDiffuse;
#include <envmap_fragment>
gl_FragColor = vec4( outgoingLight, diffuseColor.a );
#include <premultiplied_alpha_fragment>
#include <tonemapping_fragment>
#include <colorspace_fragment>
#include <fog_fragment>
}
```

[æŸ¥çœ‹æ‰€æœ‰çš„ç‰‡æ®µ](https://github.com/mrdoob/three.js/tree/dev/src/renderers/shaders/ShaderChunk)
æˆ‘ä»¬å‘ç°THREE.jsä½¿ç”¨äº†ä¸€ä¸ªåä¸º `diffuseColor` çš„å˜é‡å»ç®¡ç†åŸºæœ¬æè´¨é¢œè‰²ã€‚å®ƒåœ¨è¿™é‡Œè®¾ç½®ï¼š `<color_fragment>` [ç‰‡æ®µ](https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/color_fragment.glsl.js)
æ‰€ä»¥æˆ‘ä»¬åº”è¯¥èƒ½å¤Ÿåœ¨è¿™éƒ¨åˆ†ä¹‹åè¿›è¡Œä¿®æ”¹ã€‚

`diffuseColor`
åœ¨è¿™ä¸ªæ—¶åˆ»åº”è¯¥å·²ç»æ˜¯ä»æˆ‘ä»¬è½®å»“çº¹ç†ä¸­è·å–çš„é¢œè‰²äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬åº”è¯¥å¯ä»¥ä»è°ƒè‰²ç›˜ä¸­è·å–é¢œè‰²ï¼Œç„¶åæŠŠä»–ä»¬å’Œæœ€ç»ˆé¢œè‰²æ··åˆã€‚

å°±åƒæˆ‘ä»¬ [ä¹‹å‰åšçš„é‚£æ ·](optimize-lots-of-objects-animated.html) ï¼Œ
åœ¨[`Material.onBeforeCompile`](/api/en/materials/Material.onBeforeCompile)æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªç”¨æ¥æœç´¢å’Œæ›¿æ¢ç€è‰²å™¨ä»£ç çš„æ•°ç»„ã€‚

```js
{
const loader = new THREE.TextureLoader();
const geometry = new THREE.SphereGeometry(1, 64, 32);

const indexTexture = loader.load('resources/data/world/country-index-texture.png', render);
indexTexture.minFilter = THREE.NearestFilter;
indexTexture.magFilter = THREE.NearestFilter;

const pickingMaterial = new THREE.MeshBasicMaterial({map: indexTexture});
pickingScene.add(new THREE.Mesh(geometry, pickingMaterial));

+  const fragmentShaderReplacements = [
+    {
+      from: '#include <common>',
+      to: `
+        #include <common>
+        uniform sampler2D indexTexture;
+        uniform sampler2D paletteTexture;
+        uniform float paletteTextureWidth;
+      `,
+    },
+    {
+      from: '#include <color_fragment>',
+      to: `
+        #include <color_fragment>
+        {
+          vec4 indexColor = texture2D(indexTexture, vUv);
+          float index = indexColor.r * 255.0 + indexColor.g * 255.0 * 256.0;
+          vec2 paletteUV = vec2((index + 0.5) / paletteTextureWidth, 0.5);
+          vec4 paletteColor = texture2D(paletteTexture, paletteUV);
+          // diffuseColor.rgb += paletteColor.rgb;   // ç™½è½®å»“
+          diffuseColor.rgb = paletteColor.rgb - diffuseColor.rgb;  // é»‘è½®å»“
+        }
+      `,
+    },
+  ];

const texture = loader.load('resources/data/world/country-outlines-4k.png', render);
const material = new THREE.MeshBasicMaterial({map: texture});
+  material.onBeforeCompile = function(shader) {
+    fragmentShaderReplacements.forEach((rep) => {
+      shader.fragmentShader = shader.fragmentShader.replace(rep.from, rep.to);
+    });
+  };
scene.add(new THREE.Mesh(geometry, material));
}
```

åœ¨ä¸Šé¢å¯ä»¥çœ‹åˆ°æˆ‘ä»¬æ·»åŠ äº†3ä¸ªuniformså˜é‡ï¼Œ`indexTexture`, `paletteTexture`,
and `paletteTextureWidth`ã€‚æˆ‘ä»¬ä» `indexTexture`
è·å–é¢œè‰²ï¼Œå¹¶ä¸”æŠŠå®ƒè½¬åŒ–æˆç´¢å¼•ä¸‹æ ‡ã€‚ `vUv`
æ˜¯ç”±Three.jsæä¾›çš„çº¹ç†åæ ‡ã€‚ç„¶åæˆ‘ä»¬ä½¿ç”¨ç´¢å¼•ä¸‹æ ‡ä»è°ƒè‰²æ¿ä¸­è·å–é¢œè‰²ã€‚ç„¶åæˆ‘ä»¬ä½¿ç”¨å½“å‰çš„ `diffuseColor`å’Œæœ€ç»ˆçš„ç»“æœä½œæ··åˆã€‚
`diffuseColor`åœ¨æ­¤æ—¶æ˜¯æˆ‘ä»¬é»‘è‰²çº¹ç†ï¼Œè€Œè°ƒè‰²ç›˜æ˜¯ç™½è‰²çº¹ç†ã€‚æ‰€ä»¥å¦‚æœæˆ‘ä»¬ç›¸åŠ ä¸¤ä¸ªé¢œè‰²ï¼Œå¾—å‡ºçš„æ˜¯ç™½è‰²è½®å»“ã€‚å¦‚æœæˆ‘ä»¬äºŒè€…ç›¸å‡ï¼Œå¾—å‡ºçš„æ˜¯é»‘è‰²è½®å»“ã€‚

åœ¨æˆ‘ä»¬æ¸²æŸ“å‰ï¼Œæˆ‘ä»¬è¿˜éœ€è¦è®¾ç½®è°ƒè‰²æ¿çº¹ç†ï¼Œä»¥åŠè¿™3ä¸ªuniformså˜é‡ã€‚

å¯¹äºè°ƒè‰²æ¿çº¹ç†ï¼Œå®ƒåªéœ€è¦è¶³å¤Ÿå®½å³å¯ã€‚æ¯ä¸ªå›½å®¶ä¿ç•™ä¸€ç§é¢œè‰² + ä¸€ç§æµ·æ´‹é¢œè‰²ã€‚è¿™é‡Œæœ‰240ä¸ªå›½å®¶æˆ–åœ°åŒºï¼Œæˆ‘ä»¬å¯ä»¥ç­‰åˆ°å›½å®¶åˆ—è¡¨åŠ è½½å®Œæˆåä»¥è·å–ç¡®åˆ‡çš„æ•°å­—æ¥æŸ¥æ‰¾ã€‚ä¸è¿‡é€‰æ‹©ä¸€äº›æ›´å¤§çš„æ•°å­—æ²¡æœ‰å±å®³ï¼Œæ‰€ä»¥è®©æˆ‘ä»¬é€‰æ‹©512ã€‚

è¿™é‡Œæ˜¯åˆ›å»ºè°ƒè‰²æ¿çš„ä»£ç 

```js
const maxNumCountries = 512;
const paletteTextureWidth = maxNumCountries;
const paletteTextureHeight = 1;
const palette = new Uint8Array(paletteTextureWidth * 4);
const paletteTexture = new THREE.DataTexture(
  palette,
  paletteTextureWidth,
  paletteTextureHeight,
);
paletteTexture.minFilter = THREE.NearestFilter;
paletteTexture.magFilter = THREE.NearestFilter;
```

ä¸€ä¸ª[`DataTexture`](/api/en/textures/DataTexture) æä¾›åŸå§‹çš„çº¹ç†æ•°æ®ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ç»™ä»–512ä¸ªRGBAé¢œè‰²ï¼Œæ¯ä¸ªé¢œè‰²4å­—èŠ‚ï¼Œæ¯ä¸ªåŒ…å«0-255çš„çº¢ã€ç»¿ã€è“åˆ†é‡ã€‚

è®©æˆ‘ä»¬ç”¨éšæœºé¢œè‰²å¡«å……å®ƒï¼Œåªæ˜¯ä¸ºäº†çœ‹çœ‹å®ƒæ˜¯å¦æœ‰æ•ˆ

```js
for (let i = 1; i < palette.length; ++i) {
  palette[i] = Math.random() * 256;
}
// è®¾ç½®æµ·æ´‹é¢œè‰² (ç´¢å¼• #0)
palette.set([100, 200, 255, 255], 0);
paletteTexture.needsUpdate = true;
```

ä»»ä½•æ—¶å€™æˆ‘ä»¬æƒ³è¦Three.jsé€šè¿‡ `palette` æ•°ç»„çš„å†…å®¹æ¥æ›´æ–°è°ƒè‰²æ¿ä¸Šçš„çº¹ç†ï¼Œæˆ‘ä»¬éœ€è¦å»è®¾ç½®`paletteTexture.needsUpdate`
ä¸º `true`ã€‚

ç„¶åæˆ‘ä»¬è¿˜éœ€è¦è®¾ç½®æè´¨ä¸Šçš„uniformså˜é‡

```js
const geometry = new THREE.SphereGeometry(1, 64, 32);
const material = new THREE.MeshBasicMaterial({map: texture});
material.onBeforeCompile = function(shader) {
fragmentShaderReplacements.forEach((rep) => {
shader.fragmentShader = shader.fragmentShader.replace(rep.from, rep.to);
});
+  shader.uniforms.paletteTexture = {value: paletteTexture};
+  shader.uniforms.indexTexture = {value: indexTexture};
+  shader.uniforms.paletteTextureWidth = {value: paletteTextureWidth};
};
scene.add(new THREE.Mesh(geometry, material));
```

è¿™æ ·æˆ‘ä»¬å°±å¾—åˆ°äº†éšæœºç€è‰²çš„å›½å®¶

<iframe src="/editor?url=/manual/examples/indexed-textures-random-colors.html"></iframe>

ç°åœ¨æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ç´¢å¼•å’Œè°ƒè‰²æ¿çº¹ç†ç”Ÿæ•ˆäº†ï¼Œè®©æˆ‘ä»¬æ§åˆ¶è°ƒè‰²æ¿è¿›è¡Œé«˜äº®æ˜¾ç¤º

é¦–å…ˆè®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªå‡½æ•°ï¼Œæˆ‘ä»¬ä¼ å…¥ä¸€ä¸ªTHREE.jsé¢œè‰²ï¼Œå¹¶æ ¼å¼åŒ–ä¸ºå¯ä»¥æ”¾å…¥è°ƒè‰²æ¿çº¹ç†çš„å€¼ã€‚

```js
const tempColor = new THREE.Color();
function get255BasedColor(color) {
  tempColor.set(color);
  const base = tempColor.toArray().map((v) => v * 255);
  base.push(255); // alpha
  return base;
}
```

åƒè¿™æ ·æ¥è°ƒç”¨ `color = get255BasedColor('red')` ä¼šè¿”å›ä¸€ä¸ªåƒ `[255, 0, 0, 255]`è¿™æ ·çš„æ•°ç»„ã€‚

æ¥ä¸‹æ¥è®©æˆ‘ä»¬ç”¨å®ƒæ¥ç”Ÿæˆä¸€äº›é¢œè‰²å¹¶å¡«å……è°ƒè‰²æ¿ã€‚

```js
const selectedColor = get255BasedColor("red");
const unselectedColor = get255BasedColor("#444");
const oceanColor = get255BasedColor("rgb(100,200,255)");
resetPalette();

function setPaletteColor(index, color) {
  palette.set(color, index * 4);
}

function resetPalette() {
  // è®©æ‰€æœ‰çš„é¢œè‰²éƒ½æ˜¯æœªé€‰æ‹©çŠ¶æ€çš„é¢œè‰²
  for (let i = 1; i < maxNumCountries; ++i) {
    setPaletteColor(i, unselectedColor);
  }

  // è®¾ç½®æµ·æ´‹é¢œè‰² (ç´¢å¼• #0)
  setPaletteColor(0, oceanColor);
  paletteTexture.needsUpdate = true;
}
```

ç°åœ¨è®©æˆ‘ä»¬ä½¿ç”¨è¿™äº›å‡½æ•°æ¥æ›´æ–°è°ƒè‰²æ¿ï¼Œå½“ä¸€ä¸ªå›½å®¶è¢«é€‰ä¸­æ—¶ï¼š

```js
function getCanvasRelativePosition(event) {
const rect = canvas.getBoundingClientRect();
return {
x: (event.clientX - rect.left) * canvas.width  / rect.width,
y: (event.clientY - rect.top ) * canvas.height / rect.height,
};
}

function pickCountry(event) {
// å¦‚æœæˆ‘ä»¬è¿˜æ²¡æœ‰åŠ è½½å¥½æ•°æ®ï¼Œé€€å‡º
if (!countryInfos) {
return;
}

const position = getCanvasRelativePosition(event);
const id = pickHelper.pick(position, pickingScene, camera);
if (id > 0) {
const countryInfo = countryInfos[id - 1];
const selected = !countryInfo.selected;
if (selected &amp;&amp; !event.shiftKey &amp;&amp; !event.ctrlKey &amp;&amp; !event.metaKey) {
unselectAllCountries();
}
numCountriesSelected += selected ? 1 : -1;
countryInfo.selected = selected;
+    setPaletteColor(id, selected ? selectedColor : unselectedColor);
+    paletteTexture.needsUpdate = true;
} else if (numCountriesSelected) {
unselectAllCountries();
}
requestRenderIfNotRequested();
}

function unselectAllCountries() {
numCountriesSelected = 0;
countryInfos.forEach((countryInfo) => {
countryInfo.selected = false;
});
+  resetPalette();
}
```

æˆ‘ä»¬åº”è¯¥èƒ½å¤Ÿçªå‡ºæ˜¾ç¤º1ä¸ªæˆ–å¤šä¸ªå›½å®¶ã€‚

<iframe src="/editor?url=/manual/examples/indexed-textures-picking-and-highlighting.html"></iframe>

è¿™çœ‹èµ·æ¥æœ‰æ•ˆï¼

ä¸€ä»¶å°äº‹æ˜¯æˆ‘ä»¬ä¸èƒ½ä¸æ”¹å˜é€‰ä¸­çŠ¶æ€å°±æ¸²æŸ“åœ°çƒã€‚å¦‚æœæˆ‘ä»¬é€‰æ‹©ä¸€ä¸ªå›½å®¶ç„¶åæƒ³è¦æ—‹è½¬åœ°çƒï¼Œé€‰ä¸­çŠ¶æ€å°†æ”¹å˜ã€‚

è®©æˆ‘ä»¬å°è¯•è§£å†³è¿™ä¸ªé—®é¢˜ã€‚æˆ‘è®¤ä¸ºï¼Œæˆ‘ä»¬å¯ä»¥æ£€æŸ¥ä¸¤ä»¶äº‹æƒ…ã€‚ç‚¹å‡»å’Œæ¾å¼€ç»è¿‡äº†å¤šå°‘æ—¶é—´ï¼›ç”¨æˆ·æ˜¯å¦ç§»åŠ¨äº†é¼ æ ‡ã€‚å¦‚æœæ—¶é—´å¾ˆçŸ­ï¼Œæˆ–è€…ä»–ä»¬æ²¡æœ‰ç§»åŠ¨é¼ æ ‡ï¼Œé‚£ä¹ˆè¿™ä¸ªè¡Œä¸ºå¯èƒ½æ˜¯ç‚¹å‡»ã€‚å¦åˆ™ä»–ä»¬å¯èƒ½æ­£åœ¨å°è¯•æ‹–åŠ¨åœ°çƒã€‚

```js
+const maxClickTimeMs = 200;
+const maxMoveDeltaSq = 5 * 5;
+const startPosition = {};
+let startTimeMs;
+
+function recordStartTimeAndPosition(event) {
+  startTimeMs = performance.now();
+  const pos = getCanvasRelativePosition(event);
+  startPosition.x = pos.x;
+  startPosition.y = pos.y;
+}

function getCanvasRelativePosition(event) {
const rect = canvas.getBoundingClientRect();
return {
x: (event.clientX - rect.left) * canvas.width  / rect.width,
y: (event.clientY - rect.top ) * canvas.height / rect.height,
};
}

function pickCountry(event) {
// exit if we have not loaded the data yet
if (!countryInfos) {
return;
}

+  // å¦‚æœç”¨æˆ·è§¦å‘åå·²ç»è¿‡äº†ä¸€æ®µæ—¶é—´äº†
+  // å°±è®¤ä¸ºè¿™æ˜¯ä¸€ä¸ªæ‹–åŠ¨è¡Œä¸º
+  const clickTimeMs = performance.now() - startTimeMs;
+  if (clickTimeMs > maxClickTimeMs) {
+    return;
+  }
+
+  // å¦‚æœé¼ æ ‡ç§»åŠ¨äº†ï¼Œå°±è®¤ä¸ºè¿™æ˜¯ä¸€ä¸ªæ‹–åŠ¨è¡Œä¸º
+  const position = getCanvasRelativePosition(event);
+  const moveDeltaSq = (startPosition.x - position.x) ** 2 +
+                      (startPosition.y - position.y) ** 2;
+  if (moveDeltaSq > maxMoveDeltaSq) {
+    return;
+  }

-  const position = {x: event.clientX, y: event.clientY};
const id = pickHelper.pick(position, pickingScene, camera);
if (id > 0) {
const countryInfo = countryInfos[id - 1];
const selected = !countryInfo.selected;
if (selected &amp;&amp; !event.shiftKey &amp;&amp; !event.ctrlKey &amp;&amp; !event.metaKey) {
unselectAllCountries();
}
numCountriesSelected += selected ? 1 : -1;
countryInfo.selected = selected;
setPaletteColor(id, selected ? selectedColor : unselectedColor);
paletteTexture.needsUpdate = true;
} else if (numCountriesSelected) {
unselectAllCountries();
}
requestRenderIfNotRequested();
}

function unselectAllCountries() {
numCountriesSelected = 0;
countryInfos.forEach((countryInfo) => {
countryInfo.selected = false;
});
resetPalette();
}

+canvas.addEventListener('pointerdown', recordStartTimeAndPosition);
canvas.addEventListener('pointerup', pickCountry);
```

æ·»åŠ äº†è¿™äº›æ“ä½œï¼Œè¿™*çœ‹èµ·æ¥* å¯¹æˆ‘æœ‰æ•ˆã€‚

<iframe src="/editor?url=/manual/examples/indexed-textures-picking-debounced.html"></iframe>

æˆ‘ä¸æ˜¯ç”¨æˆ·äº¤äº’çš„ä¸“å®¶ï¼Œæ‰€ä»¥æˆ‘å¾ˆæƒ³çŸ¥é“æ˜¯å¦æœ‰æ›´å¥½çš„è§£å†³æ–¹æ¡ˆã€‚

æˆ‘å¸Œæœ›è¿™èƒ½è®©ä½ äº†è§£å›¾å½¢ç´¢å¼•çš„ç”¨å¤„ï¼Œä»¥åŠå¦‚ä½•ä¿®æ”¹Three.jsçš„ç€è‰²å™¨ä»¥æ·»åŠ ç®€å•çš„åŠŸèƒ½ã€‚å¯¹äºå¦‚ä½•ä½¿ç”¨GLSLï¼Œç¼–å†™ç€è‰²å™¨è¯­è¨€å¯¹äºæœ¬æ–‡æ¥è¯´å¤ªå¤šäº†ï¼Œè¿™ä¸ªé“¾æ¥æœ‰ä¸€äº›å°‘é‡çš„ä¿¡æ¯ï¼Œå‚è€ƒ
[å…³äºåå¤„ç†çš„è¿™ç¯‡æ–‡ç« ](post-processing.html)ã€‚
