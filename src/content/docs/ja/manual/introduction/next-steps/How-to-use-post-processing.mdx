---
title: post-processingの使い方
sidebar:
  order: 3
---

three.jsアプリケーションの多くは3Dオブジェクトをスクリーンに直接描画します。
しかしながら時々、一つ以上のエフェクト(被写界深度、Bloom、フィルムグレイン、様々なアンチエイリアス効果など)を適用したい場合があります。こういったエフェクトを実装するためにpost-processingは広く使用されています。
まず、シーンはビデオカードメモリのバッファを表す描画対象に対して描画されます。
次に、最終的なスクリーンへのレンダリングの前に、1つ以上のpost-processingで画像バッファにフィルタとエフェクトを適用します。

こういったワークフローを実装するために、three.jsは[EffectComposer](examples/postprocessing/EffectComposer)で完全なpost-processingを提供しています。

## Workflow

プロセスの一段階目はexampleディレクトリから必要なファイルを全てimportすることです。
このガイドではthree.jsの[ npm package](https://www.npmjs.com/package/three)(npmの公式のパッケージ)を使っていると想定しています。
このガイドのデモでは下に示したファイルが必要です。

```javascript
import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
import { GlitchPass } from "three/addons/postprocessing/GlitchPass.js";
import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
```

全てのファイルのimportが成功したのちに、[WebGLRenderer](api/renderers/WebGLRenderer)のインスタンスを渡すことでcomposerを作成します。

```javascript
const composer = new EffectComposer(renderer);
```

composerを使うときにはアプリケーションのアニメーションループを変更する必要があります。
[WebGLRenderer](api/renderers/WebGLRenderer)のrenderメソッドを呼ぶ代わりに[EffectComposer](examples/postprocessing/EffectComposer)のそれぞれの対応するものを使います。

```javascript
function animate() {
  requestAnimationFrame(animate);

  composer.render();
}
```

composerが準備できたので、post-processingパスのチェーンを設定できるようになりました。
これらのパスはアプリケーションの最終的なビジュアルを出力することに責任を持ちます。
これらのパスは追加/挿入の順番で処理されます。この例では、まず*RenderPass*のインスタンスが実行され、次に*GlitchPass*のインスタンスが実行され、最後に*OutputPass*が実行されます。
チェーンの中で最後の有効なpassが自動的に画面に描画されます。
passの設定は以下のように行います。

```javascript
const renderPass = new RenderPass(scene, camera);
composer.addPass(renderPass);

const glitchPass = new GlitchPass();
composer.addPass(glitchPass);

const outputPass = new OutputPass();
composer.addPass(outputPass);
```

*RenderPass*は普通チェインのはじめにあります。
これはレンダリングされたシーンを次のpost-processingの入力とするためです。
*GlitchPass*は、これらのイメージをワイルドなglitch effectを適用するために使います。
*OutputPass*は通常、連鎖の最後のパスで、sRGB カラースペースの変換とオプションのトーンマッピングを実行します。
実際に動いているものを見るために、[ sample](https://threejs.org/examples/webgl_postprocessing_glitch)を見てみましょう。

## Built-in Passes(組み込みのpass)

エンジンに元から入っている定義済みの後処理passが使えます。
このpassは[ postprocessing](https://github.com/mrdoob/three.js/tree/dev/examples/jsm/postprocessing)ディレクトリに入っていて、広範囲に使用できます。

## Custom Passes(カスタムpass)

独自のpostprocessing shaderを書いて、post-processing passのチェーンの中に組み込みたい場合があります。そういった場合には、*ShaderPass*を利用することが出来ます。
ファイルと独自のshaderをインポートしたのちに、以下のコードでpassを設定することができます。

```javascript
import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
import { LuminosityShader } from "three/addons/shaders/LuminosityShader.js";

// later in your init routine

const luminosityPass = new ShaderPass(LuminosityShader);
composer.addPass(luminosityPass);
```

リポジトリには[ CopyShader](https://github.com/mrdoob/three.js/blob/master/examples/jsm/shaders/CopyShader.js)と呼ばれるファイルがあり、カスタムshaderを作る上での良いスタートコードです。
*CopyShader*はエフェクトを適用せずに、EffectComposerの読み込みバッファの画像内容を書き込みバッファにコピーするだけです。
