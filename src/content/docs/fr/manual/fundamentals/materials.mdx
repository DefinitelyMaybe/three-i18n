---
title: Matériaux
sidebar:
  order: 2
---

Cet article fait partie d'une série consacrée à Three.js dont
le premier article s'intitule [Principes de base](fundamentals.html).
Si vous ne l'avez pas encore lu, vous devriez commencer par lui.

Three.js fournit plusieurs types de matériaux : ils définissent comment les objets apparaîtront dans la scène et par conséquent, la sélection de vos matériaux dépend fortement dans le choix de ce que vous voulez afficher.

Il existe deux façons de définir la plupart des propriétés des matériaux. La première façon est de les définir lors de la création du matériau (constructeur), comme nous l'avons déjà vu :

```js
const material = new THREE.MeshPhongMaterial({
  color: 0xff0000, // red (can also use a CSS color string here)
  flatShading: true,
});
```

La seconde façon se fait après le constructeur :

```js
const material = new THREE.MeshPhongMaterial();
material.color.setHSL(0, 1, 0.5); // red
material.flatShading = true;
```

Notez qu'il y a plusieurs façons de paramétrer la propriété [`THREE.Color`](/api/en/math/Color) :

```js
material.color.set(0x00ffff); // same as CSS's #RRGGBB style
material.color.set(cssString); // any CSS color, eg 'purple', '#F32',
// 'rgb(255, 127, 64)',
// 'hsl(180, 50%, 25%)'
material.color.set(someColor); // some other THREE.Color
material.color.setHSL(h, s, l); // where h, s, and l are 0 to 1
material.color.setRGB(r, g, b); // where r, g, and b are 0 to 1
```

Pour le constructeur, vous pouvez passer, soit un nombre hexadécimal, soit une chaîne de caractères au format CSS :

```js
const m1 = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // rouge
const m2 = new THREE.MeshBasicMaterial({ color: "red" }); // rouge
const m3 = new THREE.MeshBasicMaterial({ color: "#F00" }); // rouge
const m4 = new THREE.MeshBasicMaterial({ color: "rgb(255,0,0)" }); // rouge
const m5 = new THREE.MeshBasicMaterial({ color: "hsl(0,100%,50%)" }); // rouge
```

Examinons l'ensemble des matériaux de Three.js

Le [`MeshBasicMaterial`](/api/en/materials/MeshBasicMaterial) n'est pas affecté par la lumière.
Le [`MeshLambertMaterial`](/api/en/materials/MeshLambertMaterial) calcule la lumière sur chaque sommets (vertices) de l'objet, alors que [`MeshPhongMaterial`](/api/en/materials/MeshPhongMaterial) calculera la lumière sur chaque pixel des faces de l'objet et prendra également en compte les reflets spéculaires.

<div class="spread">
  <div>
    <div data-diagram="MeshBasicMaterial"></div>
    <div class="code">Basic</div>
  </div>
  <div>
    <div data-diagram="MeshLambertMaterial"></div>
    <div class="code">Lambert</div>
  </div>
  <div>
    <div data-diagram="MeshPhongMaterial"></div>
    <div class="code">Phong</div>
  </div>
</div>
<div class="spread">
  <div>
    <div data-diagram="MeshBasicMaterialLowPoly"></div>
  </div>
  <div>
    <div data-diagram="MeshLambertMaterialLowPoly"></div>
  </div>
  <div>
    <div data-diagram="MeshPhongMaterialLowPoly"></div>
  </div>
</div>
<div class="threejs_center code">modèles low-poly avec les mêmes matériaux</div>

Le paramètre `shininess` du [`MeshPhongMaterial`](/api/en/materials/MeshPhongMaterial) détermine la _brillance_ de la surbrillance spéculaire. La valeur par défaut est 30.

<div class="spread">
  <div>
    <div data-diagram="MeshPhongMaterialShininess0"></div>
    <div class="code">shininess: 0</div>
  </div>
  <div>
    <div data-diagram="MeshPhongMaterialShininess30"></div>
    <div class="code">shininess: 30</div>
  </div>
  <div>
    <div data-diagram="MeshPhongMaterialShininess150"></div>
    <div class="code">shininess: 150</div>
  </div>
</div>

Notez que définir la propriété `emissive` sur une couleur sur un
[`MeshLambertMaterial`](/api/en/materials/MeshLambertMaterial) ou un [`MeshPhongMaterial`](/api/en/materials/MeshPhongMaterial) et régler la propriété `color` sur noir
(et `shininess` à 0 pour Phong) finit par ressembler au [`MeshBasicMaterial`](/api/en/materials/MeshBasicMaterial).

<div class="spread">
  <div>
    <div data-diagram="MeshBasicMaterialCompare"></div>
    <div class="code">
      <div>Basic</div>
      <div>color: 'purple'</div>
    </div>
  </div>
  <div>
    <div data-diagram="MeshLambertMaterialCompare"></div>
    <div class="code">
      <div>Lambert</div>
      <div>color: 'black'</div>
      <div>emissive: 'purple'</div>
    </div>
  </div>
  <div>
    <div data-diagram="MeshPhongMaterialCompare"></div>
    <div class="code">
      <div>Phong</div>
      <div>color: 'black'</div>
      <div>emissive: 'purple'</div>
      <div>shininess: 0</div>
    </div>
  </div>
</div>

Pourquoi Three.js propose trois matériaux similaires si au final [`MeshPhongMaterial`](/api/en/materials/MeshPhongMaterial) peut faire les mêmes choses que [`MeshBasicMaterial`](/api/en/materials/MeshBasicMaterial) et [`MeshLambertMaterial`](/api/en/materials/MeshLambertMaterial) ? La raison est simple : le matériau le plus sophistiqué nécessite plus de puissance de la part du GPU. Sur un GPU plus lent comme sur un téléphone mobile, vous souhaitez peut-être améliorer les performances en utilisant un des matériaux moins gourmand en calculs GPU. Il en découle que si vous n'avez pas besoin de fonctionnalités supplémentaires, alors il vaut mieux privilégier le matériau le plus simple. Si vous n'avez pas besoin d'éclairage et de la surbrillance spéculaire alors utilisez le [`MeshBasicMaterial`](/api/en/materials/MeshBasicMaterial).

Le [`MeshToonMaterial`](/api/en/materials/MeshToonMaterial) est similaire au [`MeshPhongMaterial`](/api/en/materials/MeshPhongMaterial)
avec une grande différence : plutôt que d'ombrager en douceur, il utilise une carte de dégradé (une texture X par 1) pour décider comment ombrager. La valeur par défaut utilise une carte de dégradé dont la luminosité est de 70 % pour les premiers 70%, puis 100 % pour la suite. Vous pouvez aussi fournir votre propre carte de dégradé. Cela peut même donner une allure de dessin animé (cartoon) sur deux teintes.

<div class="spread">
  <div data-diagram="MeshToonMaterial"></div>
</div>

Ensuite, il y a deux matériaux de _rendu physique_, souvent abrégé en PBR (_Physics-Based Rendering material_).

En effet, les matériaux vus précédemment utilisent des mathématiques simples pour créer des matériaux qui semblent en 3D, mais ne réagissent pas comme dans le monde réel. Les deux matériaux PBR utilisent des mathématiques beaucoup plus complexes pour se rapprocher de ce qui se passe réellement dans le monde réel.

Le premier est [`MeshStandardMaterial`](/api/en/materials/MeshStandardMaterial). Il diffère de [`MeshPhongMaterial`](/api/en/materials/MeshPhongMaterial) et de [`MeshStandardMaterial`](/api/en/materials/MeshStandardMaterial) en utilisant différents paramètres.
[`MeshPhongMaterial`](/api/en/materials/MeshPhongMaterial) a un seul paramètre `shininess` alors que [`MeshStandardMaterial`](/api/en/materials/MeshStandardMaterial) utilise deux paramètres `roughness` (rugosité) et `metalness` (métallique).

Pour faire simple, [`roughness`](/api/en/materials/MeshStandardMaterial#roughness) est l'opposé de `shininess`.
Quelque chose qui a une rugosité élevée, comme une balle de baseball, n'a pas de reflets durs, alors que quelque chose qui n'est pas rugueux, comme une boule de billard, est très brillant. La rugosité varie de 0 à 1.

L'autre paramètre, [`metalness`](/api/en/materials/MeshStandardMaterial#metalness), indique
à quel point le matériau est métallique. Les métaux se comportent différemment des non-métaux. 0
pour le non-métal et 1 pour le métal.

Voici quelques exemples de [`MeshStandardMaterial`](/api/en/materials/MeshStandardMaterial) avec un `roughness` allant de 0 à 1
sur la droite et un `metalness` allant de 0 à 1 en descendant.

<div data-diagram="MeshStandardMaterial" style="min-height: 400px"></div>

Le [`MeshPhysicalMaterial`](/api/en/materials/MeshPhysicalMaterial) est le même que le [`MeshStandardMaterial`](/api/en/materials/MeshStandardMaterial) mais il ajoute un paramètre `clearcoat` (vernis) qui va de 0 à 1 pour savoir quelle couche vernis brillant appliquer. Et un paramètre `clearCoatRoughness` qui spécifie à quel point la couche de vernis brillant est rugueuse.

Voici la même grille que ci-dessus, mais avec les paramètres `clearcoat` et `clearCoatRoughness` en plus.

<div data-diagram="MeshPhysicalMaterial" style="min-height: 400px"></div>

Voici la liste des divers matériaux standards rangés du plus rapide au plus lent :
[`MeshBasicMaterial`](/api/en/materials/MeshBasicMaterial) ➡ [`MeshLambertMaterial`](/api/en/materials/MeshLambertMaterial) ➡ [`MeshPhongMaterial`](/api/en/materials/MeshPhongMaterial) ➡
[`MeshStandardMaterial`](/api/en/materials/MeshStandardMaterial) ➡ [`MeshPhysicalMaterial`](/api/en/materials/MeshPhysicalMaterial). Les matériaux les plus longs à calculer créent des scènes plus réalistes, mais vous devrez peut-être également concevoir votre code pour utiliser les matériaux plus rapides à calculer pour des machines mobiles ou de faible puissance.

Il existe trois matériaux qui ont des utilisations spéciales.

[`ShadowMaterial`](/api/en/materials/ShadowMaterial)
est utilisé pour obtenir les données créées à partir des ombres (sujet que nous n'avons pas encore couvert), mais nous l'utiliserons dans cet article traitant des [ombres](shadows.html).

Le [`MeshDepthMaterial`](/api/en/materials/MeshDepthMaterial) restitue la profondeur de chaque pixel où les pixels
négatifs [`near`](/api/en/cameras/PerspectiveCamera#near) sont à 0 et les négatifs [`far`](/api/en/cameras/PerspectiveCamera#far) sont à 1.
Certains effets spéciaux peuvent utiliser ces données que nous aborderons plus tard.

<div class="spread">
  <div>
    <div data-diagram="MeshDepthMaterial"></div>
  </div>
</div>

Le [`MeshNormalMaterial`](/api/en/materials/MeshNormalMaterial) vous montrera les _normales_ de la géométrie.
Les _Normales_ sont la direction d'un triangle ou d'un pixel particulier.
[`MeshNormalMaterial`](/api/en/materials/MeshNormalMaterial) dessine les normales de l'espace de vue (les normales par rapport à la caméra).

<span style="background: red;" class="color">
  x rouge
</span>
,
<span style="background: green;" class="dark-color">
  y est vert
</span>
, et
<span style="background: blue;" class="dark-color">
  z est bleu
</span>
donc les choses tournées vers la droite seront
<span style="background: #FF7F7F;" class="color">
  roses
</span>
, ceux vers la gauche seront
<span style="background: #007F7F;" class="dark-color">
  aqua
</span>
, vers le haut
<span style="background: #7FFF7F;" class="color">
  vert clair
</span>
, vers le bas
<span style="background: #7F007F;" class="dark-color">
  violet
</span>
, et vers l'écran
<span style="background: #7F7FFF;" class="color">
  lavande
</span>
.

<div class="spread">
  <div>
    <div data-diagram="MeshNormalMaterial"></div>
  </div>
</div>

[`ShaderMaterial`](/api/en/materials/ShaderMaterial) permet de créer des matériaux personnalisés à l'aide du système de shader de Three.js. [`RawShaderMaterial`](/api/en/materials/RawShaderMaterial) permet de créer des shaders entièrement personnalisés sans l'aide de Three.js. Ces deux sujets sont vastes et seront traités plus tard.

La plupart des matériaux partagent un ensemble de paramètres, tous définis par [`Material`](/api/en/materials/Material).
[Voir la documentation](/api/en/materials/Material) pour chacun d'eux, mais passons, ici, en revue deux des propriétés les plus utilisées.

[`flatShading`](/api/en/materials/Material#flatShading):
si l'objet a l'air à facettes ou lisse. Par défaut = `false`.

<div class="spread">
  <div>
    <div data-diagram="smoothShading"></div>
    <div class="code">flatShading: false</div>
  </div>
  <div>
    <div data-diagram="flatShading"></div>
    <div class="code">flatShading: true</div>
  </div>
</div>

[`side`](/api/en/materials/Material#side): quel côté montrer. La valeur par défaut est `THREE.FrontSide`.
Les autres options sont `THREE.BackSide` et `THREE.DoubleSide` (des deux côtés).
La plupart des objets 3D dessinés dans Three.js sont probablement des solides opaques, il n'est donc pas nécessaire de dessiner les faces arrières (c'est-à-dire les côtés tournés vers l'intérieur du solide). La raison la plus courante de définir le côté, est pour les plans et les objets non solides où il est courant de voir leurs faces arrières.

Voici 6 plans dessinés avec `THREE.FrontSide` et `THREE.DoubleSide`.

<div class="spread">
  <div>
    <div data-diagram="sideDefault" style="height: 250px;"></div>
    <div class="code">side: THREE.FrontSide</div>
  </div>
  <div>
    <div data-diagram="sideDouble" style="height: 250px;"></div>
    <div class="code">side: THREE.DoubleSide</div>
  </div>
</div>

Il y a vraiment beaucoup de choses à considérer avec les matériaux et il nous reste encore beaucoup à en dire. En particulier, nous avons jusqu'ici ignoré les textures, qui utilisent toute une série d'options. Avant de couvrir le domaine des textures, nous devons faire une pause et aborder [la configuration de votre environnement de développement](setup.html)

<div class="threejs_bottombar">
### material.needsUpdate

Ce sujet affecte rarement la plupart des applications Three.js, mais juste pour information
Three.js applique les paramètres de matériau lorsqu'un matériau est utilisé, où "utilisé" signifie "quelque chose est rendu qui utilise le matériau".
Certains paramètres de matériau ne sont appliqués qu'une seule fois, car leur modification nécessite beaucoup de travail de la part de Three.js.
Dans ces cas, vous devez définir `material.needsUpdate = true` pour dire à Three.js d'appliquer vos modifications matérielles. Les paramètres les plus courants qui vous obligent à définir `needsUpdate` si vous modifiez les paramètres après avoir utilisé le matériau sont :

<ul>
<li>`flatShading`</li>
<li>
ajouter ou supprimer une texture

Changer une texture est possible, mais si vous voulez passer de, aucune texture à l'utilisation d'une texture, ou l'inverse, vous devrez définir `needsUpdate = true`.

Si vous souhaitez supprimer une texture, il est préférable de la remplacer par une texture blanche de 1 pixel de côté.

</li>
</ul>

Comme mentionné ci-dessus, la plupart des applications ne rencontrent jamais ces problèmes. La plupart des applications ne basculent pas entre l'ombrage plat et l'ombrage non plat. La plupart des applications utilisent également des textures ou une couleur unie pour un matériau donné, elles passent rarement de l'une à l'autre.

</div>

<canvas id="c"></canvas>

<span>Script:src="../resources/threejs-materials.js"</span>
