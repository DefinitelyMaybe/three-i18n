---
title: Cam√©ras
sidebar:
  order: 5
---

Cet article fait partie d'une s√©rie consacr√©e √† Three.js.
Le premier article s'intitule [Principes de base](fundamentals.html).
Si vous ne l'avez pas encore lu, vous voudriez peut-√™tre commencer par l√†.

Parlons des cam√©ras dans Three.js. Nous en avons d√©j√† parl√© dans [le premier article](fundamentals.html) mais ici nous allons entrer dans le d√©tail.

La cam√©ra la plus courante dans Three.js et celle que nous avons utilis√©e jusqu'√† pr√©sent, la [`PerspectiveCamera`](https://threejs.org/api/en/cameras/PerspectiveCamera). Elle donne une vue 3D o√π les choses lointaines semblent plus petites que les plus proches.

La [`PerspectiveCamera`](/api/en/cameras/PerspectiveCamera) d√©finit un _frustum_. [Un frustum (tronc ou pyramide tronqu√©e) est une forme pyramidale solide dont la pointe est coup√©e](<https://fr.wikipedia.org/wiki/Tronc_(g%C3%A9om%C3%A9trie)>). Par nom de solide, j'entends par exemple un cube, un c√¥ne, une sph√®re, un cylindre et un frustum sont tous des noms de diff√©rents types de solides.

<div class="spread">
  <div>
    <div data-diagram="shapeCube"></div>
    <div>cube</div>
  </div>
  <div>
    <div data-diagram="shapeCone"></div>
    <div>cone</div>
  </div>
  <div>
    <div data-diagram="shapeSphere"></div>
    <div>sphere</div>
  </div>
  <div>
    <div data-diagram="shapeCylinder"></div>
    <div>cylinder</div>
  </div>
  <div>
    <div data-diagram="shapeFrustum"></div>
    <div>frustum</div>
  </div>
</div>

Je le signale seulement parce que je ne le savais pas. Et quand je voyais le mot _frustum_ dans un livre mes yeux buggaient. Comprendre que c'est le nom d'un type de forme solide a rendu ces descriptions soudainement plus logiques üòÖ

Une [`PerspectiveCamera`](/api/en/cameras/PerspectiveCamera) d√©finit son frustum selon 4 propri√©t√©s. `near` d√©finit l'endroit o√π commence l'avant du frustum. `far` o√π il finit. `fov`, le champ de vision, d√©finit la hauteur de l'avant et de l'arri√®re du tronc en fonction de la propri√©t√© `near`. L'`aspect` se rapporte √† la largeur de l'avant et de l'arri√®re du tronc. La largeur du tronc est juste la hauteur multipli√©e par l'`aspect`.

![image](/resources/frustum-3d.svg)

Utilisons la sc√®ne de [l'article pr√©c√©dent](lights.html) avec son plan, sa sph√®re et son cube, et faisons en sorte que nous puissions ajuster les param√®tres de la cam√©ra.

Pour ce faire, nous allons cr√©er un `MinMaxGUIHelper` pour les param√®tres `near` et `far` o√π `far`
est toujours sup√©rieur `near`. Il aura des propri√©t√©s `min` et `max` que lil-gui
pourra ajuster. Une fois ajust√©s, ils d√©finiront les 2 propri√©t√©s que nous sp√©cifions.

```js
class MinMaxGUIHelper {
  constructor(obj, minProp, maxProp, minDif) {
    this.obj = obj;
    this.minProp = minProp;
    this.maxProp = maxProp;
    this.minDif = minDif;
  }
  get min() {
    return this.obj[this.minProp];
  }
  set min(v) {
    this.obj[this.minProp] = v;
    this.obj[this.maxProp] = Math.max(this.obj[this.maxProp], v + this.minDif);
  }
  get max() {
    return this.obj[this.maxProp];
  }
  set max(v) {
    this.obj[this.maxProp] = v;
    this.min = this.min; // this will call the min setter
  }
}
```

Maintenant, nous pouvons configurer lil-gui comme √ßa

```js
function updateCamera() {
  camera.updateProjectionMatrix();
}

const gui = new GUI();
gui.add(camera, "fov", 1, 180).onChange(updateCamera);
const minMaxGUIHelper = new MinMaxGUIHelper(camera, "near", "far", 0.1);
gui
  .add(minMaxGUIHelper, "min", 0.1, 50, 0.1)
  .name("near")
  .onChange(updateCamera);
gui
  .add(minMaxGUIHelper, "max", 0.1, 50, 0.1)
  .name("far")
  .onChange(updateCamera);
```

Chaque fois que les param√®tres de la cam√©ra changent, il faut appeler la fonction
[`updateProjectionMatrix`](/api/en/cameras/PerspectiveCamera#updateProjectionMatrix). Nous avons donc cr√©√© une fonction `updateCamera` transmise √† lil-gui pour l'appeler lorsque les choses changent.

<iframe src="/editor?url=/manual/examples/cameras-perspective.html"></iframe>

Vous pouvez ajuster les valeurs et voir comment elles fonctionnent. Notez que nous n'avons pas rendu `aspect` r√©glable car il est pris √† partir de la taille de la fen√™tre, donc si vous souhaitez ajuster l'aspect, ouvrez l'exemple dans une nouvelle fen√™tre, puis redimensionnez la fen√™tre.

N√©anmoins, je pense que c'est un peu difficile √† voir, alors modifions l'exemple pour qu'il ait 2 cam√©ras. L'un montrera notre sc√®ne telle que nous la voyons ci-dessus, l'autre montrera une autre cam√©ra regardant la sc√®ne que la premi√®re cam√©ra dessine et montrant le frustum de cette cam√©ra.

Pour ce faire, nous pouvons utiliser la fonction ciseaux de three.js. Modifions-le pour dessiner 2 sc√®nes avec 2 cam√©ras c√¥te √† c√¥te en utilisant la fonction ciseaux.

Tout d'abord, utilisons du HTML et du CSS pour d√©finir 2 √©l√©ments c√¥te √† c√¥te. Cela nous aidera √©galement avec les √©v√©nements afin que les deux cam√©ras puissent facilement avoir leurs propres [`OrbitControls`](/examples/controls/OrbitControls).

```html
<body>
  <canvas id="c"></canvas>
  +
  <div class="split">
    +
    <div id="view1" tabindex="1"></div>
    +
    <div id="view2" tabindex="2"></div>
    +
  </div>
</body>
```

Et le CSS qui fera appara√Ætre ces 2 vues c√¥te √† c√¥te sur le canevas

```css
.split {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  display: flex;
}
.split > div {
  width: 100%;
  height: 100%;
}
```

Ensuite, ajoutons un [`CameraHelper`](/api/en/helpers/CameraHelper). Un [`CameraHelper`](/api/en/helpers/CameraHelper) dessine le frustum d'une [`Camera`](/api/en/cameras/Camera).

```js
const cameraHelper = new THREE.CameraHelper(camera);

...

scene.add(cameraHelper);
```

R√©cup√©rons maintenant nos 2 √©l√©ments.

```js
const view1Elem = document.querySelector("#view1");
const view2Elem = document.querySelector("#view2");
```

Et nous allons configurer nos [`OrbitControls`](/examples/controls/OrbitControls) pour qu'ils r√©pondent uniquement au premier √©l√©ment.

```js
-const controls = new OrbitControls(camera, canvas);
+const controls = new OrbitControls(camera, view1Elem);
```

Ajoutons une nouvelle [`PerspectiveCamera`](/api/en/cameras/PerspectiveCamera) et un second [`OrbitControls`](/examples/controls/OrbitControls).
Le deuxi√®me [`OrbitControls`](/examples/controls/OrbitControls) est li√© √† la deuxi√®me cam√©ra et re√ßoit view2Elem en param√®tre.

```js
const camera2 = new THREE.PerspectiveCamera(
  60, // fov
  2, // aspect
  0.1, // near
  500, // far
);
camera2.position.set(40, 10, 30);
camera2.lookAt(0, 5, 0);

const controls2 = new OrbitControls(camera2, view2Elem);
controls2.target.set(0, 5, 0);
controls2.update();
```

Enfin, nous devons rendre la sc√®ne du point de vue de chaque cam√©ra en utilisant la fonction `setScissor` pour ne rendre qu'une partie du canvas.

Voici une fonction qui, √©tant donn√© un √©l√©ment, calculera le rectangle de cet √©l√©ment qui chevauche le canvas. Il d√©finira ensuite les ciseaux et la fen√™tre sur ce rectangle et renverra l'aspect pour cette taille.

```js
function setScissorForElement(elem) {
  const canvasRect = canvas.getBoundingClientRect();
  const elemRect = elem.getBoundingClientRect();

  // calculer un rectangle relatif au canvas
  const right = Math.min(elemRect.right, canvasRect.right) - canvasRect.left;
  const left = Math.max(0, elemRect.left - canvasRect.left);
  const bottom = Math.min(elemRect.bottom, canvasRect.bottom) - canvasRect.top;
  const top = Math.max(0, elemRect.top - canvasRect.top);

  const width = Math.min(canvasRect.width, right - left);
  const height = Math.min(canvasRect.height, bottom - top);

  // configurer les ciseaux pour ne rendre que cette partie du canvas
  const positiveYUpBottom = canvasRect.height - bottom;
  renderer.setScissor(left, positiveYUpBottom, width, height);
  renderer.setViewport(left, positiveYUpBottom, width, height);

  // retourne aspect
  return width / height;
}
```

Et maintenant, nous pouvons utiliser cette fonction pour dessiner la sc√®ne deux fois dans notre fonction `render`

```js
function render() {

-    if (resizeRendererToDisplaySize(renderer)) {
-      const canvas = renderer.domElement;
-      camera.aspect = canvas.clientWidth / canvas.clientHeight;
-      camera.updateProjectionMatrix();
-    }

+    resizeRendererToDisplaySize(renderer);
+
+    // d√©clenche la fonction setScissorTest
+    renderer.setScissorTest(true);
+
+    // rend la vue originelle
+    {
+      const aspect = setScissorForElement(view1Elem);
+
+      // ajuste la cam√©ra pour cet aspect
+      camera.aspect = aspect;
+      camera.updateProjectionMatrix();
+      cameraHelper.update();
+
+      // ne pas ajouter le camera helper dans la vue originelle
+      cameraHelper.visible = false;
+
+      scene.background.set(0x000000);
+
+      // rendu
+      renderer.render(scene, camera);
+    }
+
+    // rendu de la 2e cam√©ra
+    {
+      const aspect = setScissorForElement(view2Elem);
+
+      // ajuste la cam√©ra
+      camera2.aspect = aspect;
+      camera2.updateProjectionMatrix();
+
+      // camera helper dans la 2e vue
+      cameraHelper.visible = true;
+
+      scene.background.set(0x000040);
+
+      renderer.render(scene, camera2);
+    }

-    renderer.render(scene, camera);

requestAnimationFrame(render);
}

requestAnimationFrame(render);
}
```

Le code ci-dessus d√©finit la couleur d'arri√®re-plan de la sc√®ne lors du rendu de la deuxi√®me vue en bleu fonc√© juste pour faciliter la distinction des deux vues.

Nous pouvons √©galement supprimer notre code `updateCamera` puisque nous mettons tout √† jour dans la fonction `render`.

```js
-function updateCamera() {
-  camera.updateProjectionMatrix();
-}

const gui = new GUI();
-gui.add(camera, 'fov', 1, 180).onChange(updateCamera);
+gui.add(camera, 'fov', 1, 180);
const minMaxGUIHelper = new MinMaxGUIHelper(camera, 'near', 'far', 0.1);
-gui.add(minMaxGUIHelper, 'min', 0.1, 50, 0.1).name('near').onChange(updateCamera);
-gui.add(minMaxGUIHelper, 'max', 0.1, 50, 0.1).name('far').onChange(updateCamera);
+gui.add(minMaxGUIHelper, 'min', 0.1, 50, 0.1).name('near');
+gui.add(minMaxGUIHelper, 'max', 0.1, 50, 0.1).name('far');
```

Et maintenant, vous pouvez utiliser une vue pour voir le frustum de l'autre.

<iframe src="/editor?url=/manual/examples/cameras-perspective-2-scenes.html"></iframe>

Sur la gauche, vous pouvez voir la vue d'origine et sur la droite, vous pouvez voir une vue montrant le frustum sur la gauche. Lorsque vous ajustez `near`, `far`, `fov` et d√©placez la cam√©ra avec la souris, vous pouvez voir que seul ce qui se trouve √† l'int√©rieur du frustum montr√© √† droite appara√Æt dans la sc√®ne √† gauche.

Ajustez `near` d'environ 20 et vous verrez facilement le devant des objets dispara√Ætre car ils ne sont plus dans le tronc. Ajustez `far` en dessous de 35 et vous commencerez √† voir le sol dispara√Ætre car il n'est plus dans le tronc.

Cela soul√®ve la question, pourquoi ne pas simplement d√©finir `near` de 0,0000000001 et `far` de 100000000000000 ou quelque chose comme √ßa pour que vous puissiez tout voir? Parce que votre GPU n'a qu'une pr√©cision limit√©e pour d√©cider si quelque chose est devant ou derri√®re quelque chose d'autre. Cette pr√©cision se r√©partit entre `near` et `far`. Pire, par d√©faut la pr√©cision au plus pr√®s de la cam√©ra est pr√©cise tandis que celle la plus lointaine de la cam√©ra est grossi√®re. Les unit√©s commencent par `near` et s'√©tendent lentement √† mesure qu'elles s'approchent de `far`.

En commen√ßant par l'exemple du haut, modifions le code pour ins√©rer 20 sph√®res d'affil√©e.

```js
{
  const sphereRadius = 3;
  const sphereWidthDivisions = 32;
  const sphereHeightDivisions = 16;
  const sphereGeo = new THREE.SphereGeometry(
    sphereRadius,
    sphereWidthDivisions,
    sphereHeightDivisions,
  );
  const numSpheres = 20;
  for (let i = 0; i < numSpheres; ++i) {
    const sphereMat = new THREE.MeshPhongMaterial();
    sphereMat.color.setHSL(i * 0.73, 1, 0.5);
    const mesh = new THREE.Mesh(sphereGeo, sphereMat);
    mesh.position.set(
      -sphereRadius - 1,
      sphereRadius + 2,
      i * sphereRadius * -2.2,
    );
    scene.add(mesh);
  }
}
```

et d√©finissons `near` √† 0.00001

```js
const fov = 45;
const aspect = 2;  // valeur par d√©faut
-const near = 0.1;
+const near = 0.00001;
const far = 100;
const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
```

Nous devons √©galement modifier un peu le code de lil-gui pour autoriser 0,00001 si la valeur est modifi√©e.

```js
-gui
  .add(minMaxGUIHelper, "min", 0.1, 50, 0.1)
  .name("near")
  .onChange(updateCamera);
+gui
  .add(minMaxGUIHelper, "min", 0.00001, 50, 0.00001)
  .name("near")
  .onChange(updateCamera);
```

Que pensez-vous qu'il va se passer ?

<iframe src="/editor?url=/manual/examples/cameras-z-fighting.html"></iframe>

Ceci est un exemple de _z fighting_ o√π le GPU de votre ordinateur n'a pas assez de pr√©cision pour d√©cider quels pixels sont devant et quels pixels sont derri√®re.

Juste au cas o√π le probl√®me ne s'afficherait pas sur votre machine, voici ce que je vois sur la mienne.

<div class="threejs_center">![image](/resources/images/z-fighting.png)</div>

Une solution consiste √† indiquer √† Three.js d'utiliser une m√©thode diff√©rente pour calculer quels pixels sont devant et lesquels sont derri√®re. Nous pouvons le faire en activant `logarithmicDepthBuffer` lorsque nous cr√©ons le [`WebGLRenderer`](https://threejs.org/api/en/renderers/WebGLRenderer)

```js
-const renderer = new THREE.WebGLRenderer({antialias: true, canvas});
+const renderer = new THREE.WebGLRenderer({
+  antialias: true,
+  canvas,
+  logarithmicDepthBuffer: true,
+});
```

et avec √ßa, √ßa devrait marcher.

<iframe src="/editor?url=/manual/examples/cameras-logarithmic-depth-buffer.html"></iframe>

Si cela n'a pas r√©solu le probl√®me pour vous, vous avez rencontr√© une raison pour laquelle vous ne pouvez pas toujours utiliser cette solution. Cette raison est due au fait que seuls certains GPU le prennent en charge. En septembre 2018, presque aucun appareil mobile ne prenait en charge cette solution, contrairement √† la plupart des ordinateurs de bureau.

Une autre raison de ne pas choisir cette solution est qu'elle peut √™tre nettement plus lente que la solution standard.

M√™me avec cette solution, la r√©solution est encore limit√©e. Rendez `near` encore plus petit ou `far` plus grand et vous finirez par rencontrer les m√™mes probl√®mes.

Cela signifie que vous devez toujours faire un effort pour choisir un param√®tre `near` et `far` qui correspond √† votre cas d'utilisation. Placez `near` aussi loin que possible de la cam√©ra sans que rien ne disparaisse. Placez `far` aussi pr√®s que possible de la cam√©ra et, de m√™me, de fa√ßon √† ce que tout reste visible. Si vous essayez de dessiner une sc√®ne g√©ante et de montrer en gros plan un visage de fa√ßon √† voir ses cils, tandis qu'en arri√®re-plan il soit possible de voir les montagnes √† 50 kilom√®tres de distance, vous devrez trouver d'autres solutions cr√©atives, nous-y reviendrons peut-√™tre plus tard. Pour l'instant, sachez que vous devez prendre soin de choisir des valeurs `near` et `far` appropri√©es √† vos besoins.

La deuxi√®me cam√©ra la plus courante est l'[`OrthographicCamera`](https://threejs.org/api/en/cameras/OrthographicCamera). Plut√¥t que de d√©finir un frustum, il faut sp√©cifier une bo√Æte avec les param√®tres `left`, `right`, `top`, `bottom`, `near` et `far`. Comme elle projette une bo√Æte, il n'y a pas de perspective.

Changeons notre exemple pr√©c√©dent pour utiliser une [`OrthographicCamera`](/api/en/cameras/OrthographicCamera) dans la premi√®re vue.

D'abord, param√©trons notre [`OrthographicCamera`](/api/en/cameras/OrthographicCamera).

```js
const left = -1;
const right = 1;
const top = 1;
const bottom = -1;
const near = 5;
const far = 50;
const camera = new THREE.OrthographicCamera(
  left,
  right,
  top,
  bottom,
  near,
  far,
);
camera.zoom = 0.2;
```

D√©finissons `left` and `bottom` √† -1 et `right` et `top` √† 1. On devrait obtenir une bo√Æte de 2 unit√©s de large et 2 unit√©s de haut, mais nous allons ajuster `left` et `top` en fonction de l'aspect du rectangle sur lequel nous dessinons. Nous utiliserons la propri√©t√© `zoom` pour faciliter le r√©glage du nombre d'unit√©s r√©ellement affich√©es par la cam√©ra.

Ajoutons un nouveau param√®tre √† lil-gui pour le `zoom`.

```js
const gui = new GUI();
+gui.add(camera, "zoom", 0.01, 1, 0.01).listen();
```

L'appel √† `listen` dit √† lil-gui de surveiller les changements. Il faut faire cela parce que [`OrbitControls`](/examples/controls/OrbitControls) peut contr√¥ler le zoom. Par exemple, la molette de d√©filement d'une souris zoomera via les [`OrbitControls`](/examples/controls/OrbitControls).

Enfin, nous avons juste besoin de changer la partie qui rend le c√¥t√© gauche pour mettre √† jour la [`OrthographicCamera`](/api/en/cameras/OrthographicCamera).

```js
{
const aspect = setScissorForElement(view1Elem);

// mettre √† jour la cam√©ra pour cet aspect
-  camera.aspect = aspect;
+  camera.left   = -aspect;
+  camera.right  =  aspect;
camera.updateProjectionMatrix();
cameraHelper.update();

// ne pas dessiner le camera helper dans la vue d'origine
cameraHelper.visible = false;

scene.background.set(0x000000);
renderer.render(scene, camera);
}
```

et maintenant vous pouvez voir une [`OrthographicCamera`](/api/en/cameras/OrthographicCamera) au boulot.

<iframe src="/editor?url=/manual/examples/cameras-orthographic-2-scenes.html"></iframe>

Une [`OrthographicCamera`](/api/en/cameras/OrthographicCamera) est souvent utilis√©e pour dessiner des objets en 2D. Il faut d√©cider du nombre d'unit√©s que la cam√©ra doit afficher. Par exemple, si vous voulez qu'un pixel du canvas corresponde √† une unit√© de la camera avec l'origine au centre, vous pouvez faire quelque chose comme.

```js
camera.left = -canvas.width / 2;
camera.right = canvas.width / 2;
camera.top = canvas.height / 2;
camera.bottom = -canvas.height / 2;
camera.near = -1;
camera.far = 1;
camera.zoom = 1;
```

Ou si nous voulions que l'origine soit en haut √† gauche comme un canvas 2D, nous pourrions utiliser ceci

```js
camera.left = 0;
camera.right = canvas.width;
camera.top = 0;
camera.bottom = canvas.height;
camera.near = -1;
camera.far = 1;
camera.zoom = 1;
```

Dans ce cas, le coin sup√©rieur gauche serait √† 0,0 tout comme un canvas 2D.

Essayons! Commen√ßons par configurer la cam√©ra.

```js
const left = 0;
const right = 300; // taille par d√©faut
const top = 0;
const bottom = 150; // taille par d√©faut
const near = -1;
const far = 1;
const camera = new THREE.OrthographicCamera(
  left,
  right,
  top,
  bottom,
  near,
  far,
);
camera.zoom = 1;
```

Chargeons ensuite 6 textures et cr√©ons 6 plans, un pour chaque texture. Chaque plan sera un enfant d'un [`THREE.Object3D`](/api/en/core/Object3D) pour faciliter le d√©calage du plan afin que son centre semble √™tre dans son coin sup√©rieur gauche.

Pour travailler en local sur votre machine, vous aurez besoin d'une [configuration sp√©cifique](setup.html).
Vous voudrez peut-√™tre en savoir plus sur [l'utilisation des textures](textures.html).

```js
const loader = new THREE.TextureLoader();
const textures = [
  loader.load("resources/images/flower-1.jpg"),
  loader.load("resources/images/flower-2.jpg"),
  loader.load("resources/images/flower-3.jpg"),
  loader.load("resources/images/flower-4.jpg"),
  loader.load("resources/images/flower-5.jpg"),
  loader.load("resources/images/flower-6.jpg"),
];
const planeSize = 256;
const planeGeo = new THREE.PlaneGeometry(planeSize, planeSize);
const planes = textures.map((texture) => {
  const planePivot = new THREE.Object3D();
  scene.add(planePivot);
  texture.magFilter = THREE.NearestFilter;
  const planeMat = new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.DoubleSide,
  });
  const mesh = new THREE.Mesh(planeGeo, planeMat);
  planePivot.add(mesh);
  // d√©placer le plan pour que le coin sup√©rieur gauche soit l'origine
  mesh.position.set(planeSize / 2, planeSize / 2, 0);
  return planePivot;
});
```

et nous devons mettre √† jour la cam√©ra si la taille de la toile change.

```js
function render() {

if (resizeRendererToDisplaySize(renderer)) {
camera.right = canvas.width;
camera.bottom = canvas.height;
camera.updateProjectionMatrix();
}

...
```

`planes` est un tableau de [`THREE.Mesh`](/api/en/objects/Mesh).
D√©pla√ßons-les en fonction du temps.

```js
function render(time) {
time *= 0.001;  // convertir en secondes;

...

const distAcross = Math.max(20, canvas.width - planeSize);
const distDown = Math.max(20, canvas.height - planeSize);

// distance totale √† parcourir
const xRange = distAcross * 2;
const yRange = distDown * 2;
const speed = 180;

planes.forEach((plane, ndx) => {
// calculer un temps unique pour chaque plan
const t = time * speed + ndx * 300;

// d√©finir une valeur entre 0 et une plage
const xt = t % xRange;
const yt = t % yRange;

// d√©finit notre position en avant si 0 √† la moiti√© de la plage
// et vers l'arri√®re si la moiti√© de la plage √† la plage
const x = xt < distAcross ? xt : xRange - xt;
const y = yt < distDown   ? yt : yRange - yt;

plane.position.set(x, y, 0);
});

renderer.render(scene, camera);
```

Et vous pouvez voir les images rebondir parfaitement sur les bords du canvas en utilisant les math√©matiques des pixels, tout comme un canvas 2D.

<iframe src="/editor?url=/manual/examples/cameras-orthographic-canvas-top-left-origin.html"></iframe>

Une autre utilisation courante d'une cam√©ra orthographique est de dessiner les vues haut, bas, gauche, droite, avant et arri√®re d'un programme de mod√©lisation 3D ou d'un √©diteur de moteur de jeu.

<div class="threejs_center">![image](/resources/images/quad-viewport.png)</div>

Dans la capture d'√©cran ci-dessus, vous pouvez voir qu'une vue est une vue en perspective et que les 3 autres vues sont des vues orthogonales.

C'est la base des cam√©ras. Nous aborderons quelques fa√ßons courantes de d√©placer les cam√©ras dans d'autres articles. Pour l'instant passons aux [ombres](shadows.html).

<canvas id="c"></canvas>

<span>Script:src="../resources/threejs-cameras.js"</span>
